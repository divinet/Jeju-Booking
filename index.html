<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>VILLA LIBRA</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; color: #111; }
      .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 16px; }
      input[type="text"] { padding: 8px 10px; font-size: 14px; }
      button { padding: 8px 12px; font-size: 14px; cursor: pointer; }
      .calendar { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; position: relative; }
      .day { border: 1px solid #ddd; padding: 10px; min-height: 54px; border-radius: 6px; background: #fff; display: flex; flex-direction: column; gap: 6px; }
      .blank { min-height: 54px; }
      .day .dnum { font-weight: 600; font-size: 12px; color: #666; }
      .day.selecting { background: #e7f5ff; border-color: #a5d8ff; }
      .day.select-start { background: #d3f9d8; border-color: #8ce99a; }
      .day.select-end { background: #fff3bf; border-color: #ffd43b; }
      .day.mine { background: #e6f4ff; border-color: #b3ddff; }
      .day.other { background: #f8f9fa; }
      .legend { display: flex; gap: 12px; margin: 8px 0 16px; color: #555; font-size: 13px; }
      .legend span { display: inline-flex; align-items: center; gap: 6px; }
      .swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; border: 1px solid #ccc; }
      .swatch.mine { background: #e6f4ff; border-color: #b3ddff; }
      .swatch.other { background: #f8f9fa; }
      .months { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; }
      .month { border: 1px solid #eee; border-radius: 8px; padding: 12px; }
      .month h3 { margin: 0 0 8px; font-size: 16px; }
      .summary { margin-top: 24px; }
      table { border-collapse: collapse; width: 100%; max-width: 520px; }
      th, td { border: 1px solid #eee; padding: 8px; text-align: left; }
      th { background: #fafafa; }
      .muted { color: #888; font-size: 13px; }
      .day.sun { border-color: #fa5252; }
      .day.sat { border-color: #228be6; }
      .day.holiday { border-color: #fa5252; }
      .res-bar { border-radius: 6px; padding: 4px 8px; align-self: stretch; justify-self: stretch; display: flex; align-items: center; justify-content: center; font-weight: 600; z-index: 2; pointer-events: auto; cursor: pointer; }
      .res-bar.mine { background: rgba(173, 216, 230, 0.55); border: 1px solid #a5d8ff; color: #0b7285; }
      .res-bar.other { background: #f1f3f5; border: 1px solid #dee2e6; color: #495057; }
      /* Bars overlay */
      .res-overlay { position: absolute; inset: 0; display: grid; grid-template-columns: inherit; gap: 6px; pointer-events: none; }
      /* Modal */
      .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 1000; }
      .modal { background: #fff; width: min(92vw, 420px); border-radius: 10px; box-shadow: 0 12px 28px rgba(0,0,0,0.2); overflow: hidden; }
      .modal-header { padding: 12px 16px; font-weight: 700; border-bottom: 1px solid #eee; }
      .modal-body { padding: 16px; color: #333; }
      .modal-actions { display: flex; gap: 8px; justify-content: flex-end; padding: 12px 16px; border-top: 1px solid #eee; }
      .btn { padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: #fff; cursor: pointer; }
      .btn-primary { background: #228be6; color: #fff; border-color: #228be6; }
    </style>
    <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  </head>
  <body>
    <h1>VILLA LIBRA</h1>

    <div class="row">
      <label>이름:
        <input id="nameInput" type="text" placeholder="이름을 입력" list="membersList" />
        <datalist id="membersList">
          <option value="이시원"></option>
          <option value="김영달"></option>
          <option value="서정훈"></option>
          <option value="박승원"></option>
          <option value="지승환"></option>
          <option value="손지호"></option>
          <option value="김강안"></option>
          <option value="신현성"></option>
          <option value="민용재"></option>
          <option value="배봉건"></option>
          <option value="변성윤"></option>
        </datalist>
      </label>
      <button id="saveNameBtn">입장</button>
      <span id="nameStatus" class="muted"></span>
    </div>

    <div class="legend">
      <span><span class="swatch"></span> 비어있음</span>
      <span><span class="swatch mine"></span> 내 예약</span>
      <span><span class="swatch other"></span> 타인 예약</span>
    </div>

    <div class="row">
      <button id="bookBtn" disabled>선택한 날짜 예약</button>
      <span class="muted">2일 이상 연속으로 선택해야 합니다.</span>
    </div>

    <div id="months" class="months"></div>

    <div class="summary">
      <h2>멤버별 총 숙박일</h2>
      <table>
        <thead><tr><th>이름</th><th>총 일수</th></tr></thead>
        <tbody id="summaryBody"></tbody>
      </table>
    </div>

    <div id="modalBackdrop" class="modal-backdrop">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div id="modalTitle" class="modal-header"></div>
        <div id="modalMessage" class="modal-body"></div>
        <div id="modalActions" class="modal-actions"></div>
      </div>
    </div>

    <script>
      // 1) Configure Supabase
      const SUPABASE_URL = "https://YOUR-PROJECT.supabase.co"; // <- replace
      const SUPABASE_ANON_KEY = "YOUR_ANON_PUBLIC_KEY";        // <- replace
      const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      const isDemoMode = SUPABASE_URL.includes("YOUR-PROJECT") || SUPABASE_ANON_KEY.includes("YOUR_");

      // 2) App state
      let currentName = localStorage.getItem("member_name") || "";
      let bookingsByDay = new Map(); // 'YYYY-MM-DD' -> member_name
      let selectingStart = null;
      let selectingEnd = null;
      const minNights = 2; // inclusive of nights: requires 2 consecutive days

      // 3) Helpers
      const fmtDate = (d) => {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      };
      const parseDate = (s) => {
        const [y, m, d] = s.split("-").map(Number);
        return new Date(y, m - 1, d);
      };
      const addDays = (d, n) => new Date(d.getFullYear(), d.getMonth(), d.getDate() + n);
      const rangeInclusive = (start, end) => {
        const out = [];
        let cur = new Date(start);
        while (cur <= end) {
          out.push(fmtDate(cur));
          cur = addDays(cur, 1);
        }
        return out;
      };
      const nightCount = (startStr, endStr) => {
        const start = parseDate(startStr), end = parseDate(endStr);
        return Math.max(0, Math.round((end - start) / 86400000) + 1);
      };

      const nameInput = document.getElementById("nameInput");
      const saveNameBtn = document.getElementById("saveNameBtn");
      const nameStatus = document.getElementById("nameStatus");
      const monthsEl = document.getElementById("months");
      const bookBtn = document.getElementById("bookBtn");
      const summaryBody = document.getElementById("summaryBody");
      const modalBackdrop = document.getElementById("modalBackdrop");
      const modalTitle = document.getElementById("modalTitle");
      const modalMessage = document.getElementById("modalMessage");
      const modalActions = document.getElementById("modalActions");

      const monthNames = ["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"];
      const weekdayNames = ["일","월","화","수","목","금","토"];
      const calendarStartYear = 2025;
      const calendarStartMonthIdx = 10; // 0-indexed → 10 = 11월
      const monthsToShow = 24; // 스크롤로 쭉 내려볼 수 있도록 충분히 많이 표시

      const allowedMembers = [
        "이시원","김영달","서정훈","박승원","지승환",
        "손지호","김강안","신현성","민용재","배봉건","변성윤"
      ];
      const isAllowedMember = (name) => allowedMembers.includes(name.trim());

      // 공휴일: YYYY-MM-DD → 이름
      const holidays = new Map([
        ["2025-12-25", "성탄절"],
        ["2026-01-01", "신정"],
        ["2026-02-16", "설날 연휴"],
        ["2026-02-17", "설날"],
        ["2026-02-18", "설날 연휴"],
        ["2026-03-02", "대체공휴일(3·1절)"],
        ["2026-05-05", "어린이날"],
        ["2026-05-25", "대체공휴일(부처님 오신날)"],
        ["2026-06-06", "현충일"],
        ["2026-08-15", "광복절"],
        ["2026-08-17", "대체공휴일(광복절)"],
        ["2026-09-24", "추석 연휴"],
        ["2026-09-25", "추석"],
        ["2026-09-26", "추석 연휴"],
        ["2026-10-05", "대체공휴일(개천절)"],
        ["2026-10-09", "한글날"],
        ["2026-12-25", "크리스마스"],
      ]);

      // 4) Calendar render
      function buildMonth(year, monthIdx) {
        const first = new Date(year, monthIdx, 1);
        const last = new Date(year, monthIdx + 1, 0);
        const startGrid = new Date(year, monthIdx, 1 - first.getDay());
        const endGrid = new Date(year, monthIdx + 1, 6 - last.getDay());
        const wrapper = document.createElement("div");
        wrapper.className = "month";

        const h = document.createElement("h3");
        h.textContent = `${year}년 ${monthNames[monthIdx]}`;
        wrapper.appendChild(h);

        // Weekday header
        const header = document.createElement("div");
        header.className = "calendar";
        weekdayNames.forEach(w => {
          const e = document.createElement("div");
          e.className = "muted";
          e.style.textAlign = "center";
          e.textContent = w;
          header.appendChild(e);
        });
        wrapper.appendChild(header);

        // Days grid
        const grid = document.createElement("div");
        grid.className = "calendar";

        for (let d = new Date(startGrid); d <= endGrid; d = addDays(d, 1)) {
          const inMonth = d.getMonth() === monthIdx;
          if (!inMonth) {
            const blank = document.createElement("div");
            blank.className = "blank";
            grid.appendChild(blank);
            continue;
          }
          const dayEl = document.createElement("div");
          dayEl.className = "day";
          const dow = d.getDay();
          if (dow === 0) dayEl.classList.add("sun");
          if (dow === 6) dayEl.classList.add("sat");

          const label = document.createElement("div");
          label.className = "dnum";
          label.textContent = d.getDate();
          dayEl.appendChild(label);

          const nameEl = document.createElement("div");
          nameEl.className = "who";
          nameEl.style.fontSize = "13px";
          nameEl.style.minHeight = "18px";
          dayEl.appendChild(nameEl);

          const dateStr = fmtDate(d);
          dayEl.dataset.date = dateStr;
          if (holidays.has(dateStr)) {
            dayEl.classList.add("holiday");
            dayEl.title = holidays.get(dateStr);
          }

          dayEl.addEventListener("click", () => onDayClick(dateStr));

          grid.appendChild(dayEl);
        }

        // overlay for reservation bars
        const overlay = document.createElement("div");
        overlay.className = "res-overlay";
        grid.appendChild(overlay);

        wrapper.appendChild(grid);
        return wrapper;
      }

      function renderMonths() {
        monthsEl.innerHTML = "";
        for (let i = 0; i < monthsToShow; i++) {
          const dt = new Date(calendarStartYear, calendarStartMonthIdx + i, 1);
          monthsEl.appendChild(buildMonth(dt.getFullYear(), dt.getMonth()));
        }
        paintBookings();
        paintSelection();
      }

      // Modal helpers
      function openModal(title, message, buttons) {
        modalTitle.textContent = title || "";
        if (typeof message === "string") {
          modalMessage.textContent = message;
        } else {
          modalMessage.innerHTML = "";
          if (message instanceof Node) modalMessage.appendChild(message);
        }
        modalActions.innerHTML = "";
        for (const { label, variant, resolveValue } of buttons) {
          const btn = document.createElement("button");
          btn.className = `btn ${variant || ""}`.trim();
          btn.textContent = label;
          btn.addEventListener("click", () => {
            closeModal();
            if (typeof resolveValue === "function") resolveValue();
          });
          modalActions.appendChild(btn);
        }
        modalBackdrop.style.display = "flex";
      }
      function closeModal() { modalBackdrop.style.display = "none"; }
      function infoModal(message, title = "알림") {
        return new Promise((resolve) => {
          openModal(title, message, [
            { label: "확인", variant: "btn-primary", resolveValue: resolve }
          ]);
        });
      }
      function confirmModal(message, title = "확인") {
        return new Promise((resolve) => {
          openModal(title, message, [
            { label: "아니오", variant: "", resolveValue: () => resolve(false) },
            { label: "예", variant: "btn-primary", resolveValue: () => resolve(true) }
          ]);
        });
      }

      async function selectMemberModal(title = "예약자 선택") {
        return new Promise((resolve) => {
          const list = document.createElement("div");
          list.style.display = "grid";
          list.style.gridTemplateColumns = "repeat(2, 1fr)";
          list.style.gap = "8px";
          allowedMembers.forEach(name => {
            const btn = document.createElement("button");
            btn.className = "btn";
            btn.textContent = name;
            btn.style.textAlign = "center";
            btn.addEventListener("click", () => { closeModal(); resolve(name); });
            list.appendChild(btn);
          });
          openModal(title, list, [
            { label: "취소", variant: "", resolveValue: () => resolve(null) }
          ]);
        });
      }

      // 5) Painting
      function paintBookings() {
        document.querySelectorAll(".day").forEach(el => {
          const dateStr = el.dataset.date;
          const who = bookingsByDay.get(dateStr);
          const whoEl = el.querySelector(".who");
          // 개별 박스 내 텍스트는 지우고, 구간 바에 이름을 표시
          whoEl.textContent = "";
          el.classList.remove("mine","other");
          if (who) {
            if (currentName && who === currentName) el.classList.add("mine");
            else el.classList.add("other");
          }
        });
        paintReservationBars();
        renderSummary();
        updateNameStatus();
      }

      function updateNameStatus() {
        if (!currentName) { nameStatus.textContent = ""; return; }
        let mineCount = 0;
        for (const who of bookingsByDay.values()) if (who === currentName) mineCount++;
        nameStatus.textContent = `입장됨: ${currentName} (${mineCount}일)`;
      }

      function paintReservationBars() {
        // 월별 그리드마다 기존 바 제거
        document.querySelectorAll('.month').forEach(monthEl => {
          const grids = monthEl.querySelectorAll('.calendar');
          if (grids.length < 2) return;
          const grid = grids[1]; // 두 번째 .calendar가 날짜 그리드
          const overlay = grid.querySelector('.res-overlay') || (() => { const o = document.createElement('div'); o.className = 'res-overlay'; grid.appendChild(o); return o; })();
          overlay.querySelectorAll('.res-bar').forEach(b => b.remove());

          // day elements only (exclude overlay)
          const dayEls = Array.from(grid.children).filter(c => c.classList && (c.classList.contains('day') || c.classList.contains('blank')));
          const numRows = Math.ceil(dayEls.length / 7);
          overlay.style.gridTemplateRows = `repeat(${numRows}, 1fr)`;
          // 6주 * 7일 = 42개 (가정)
          for (let row = 0; row < 6; row++) {
            let col = 0;
            while (col < 7) {
              const i = row * 7 + col;
              const el = dayEls[i];
              if (!el || !el.classList || !el.classList.contains('day')) { col++; continue; }
              const dateStr = el.dataset.date;
              const who = bookingsByDay.get(dateStr);
              if (!who) { col++; continue; }
              // 연속 구간 길이 계산 (같은 이름)
              let span = 1;
              for (let c = col + 1; c < 7; c++) {
                const j = row * 7 + c;
                const el2 = dayEls[j];
                if (!el2 || !el2.classList || !el2.classList.contains('day')) break;
                const who2 = bookingsByDay.get(el2.dataset.date);
                if (who2 === who) span++; else break;
              }
              // 바 생성
              const bar = document.createElement('div');
              bar.className = 'res-bar';
              bar.textContent = who;
              bar.style.gridColumn = `${col + 1} / span ${span}`;
              bar.style.gridRow = `${row + 1}`;
              // start/end/owner metadata
              const startDate = dayEls[i]?.dataset?.date;
              const endDate = dayEls[i + span - 1]?.dataset?.date;
              if (startDate) bar.dataset.start = startDate;
              if (endDate) bar.dataset.end = endDate;
              bar.dataset.who = who;
              if (currentName && who === currentName) bar.classList.add('mine');
              else bar.classList.add('other');
              bar.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                const owner = bar.dataset.who;
                const s = bar.dataset.start;
                const e = bar.dataset.end;
                if (!s || !e) return;
                if (!currentName) { await infoModal("먼저 이름을 입력하고 입장 버튼을 눌러주세요."); return; }
                if (currentName !== owner) { await infoModal(`${s} ~ ${e} 구간은 ${owner}님의 예약입니다.`); return; }
                const ok = await confirmModal(`${s} ~ ${e} 예약을 취소하시겠습니까?`);
                if (!ok) return;
                const [a, b] = [parseDate(s), parseDate(e)].sort((x,y)=>x-y);
                const dates = rangeInclusive(a, b);
                await cancelDates(dates);
              });
              overlay.appendChild(bar);
              col += span;
            }
          }
        });
      }

      function paintSelection() {
        document.querySelectorAll(".day").forEach(el => el.classList.remove("selecting","select-start","select-end"));
        // Only start chosen → highlight start day
        if (selectingStart && !selectingEnd) {
          const startEl = document.querySelector(`.day[data-date="${selectingStart}"]`);
          if (startEl) startEl.classList.add("select-start");
          bookBtn.disabled = true;
          return;
        }
        // Range chosen → highlight full span and mark ends
        if (selectingStart && selectingEnd) {
          const nights = nightCount(selectingStart, selectingEnd);
          bookBtn.disabled = nights < minNights;
          const [a, b] = [parseDate(selectingStart), parseDate(selectingEnd)].sort((x,y)=>x-y);
          for (let d = new Date(a); d <= b; d = addDays(d, 1)) {
            const ds = fmtDate(d);
            const el = document.querySelector(`.day[data-date="${ds}"]`);
            if (el) el.classList.add("selecting");
          }
          const startEl = document.querySelector(`.day[data-date="${fmtDate(a)}"]`);
          const endEl = document.querySelector(`.day[data-date="${fmtDate(b)}"]`);
          if (startEl) startEl.classList.add("select-start");
          if (endEl) endEl.classList.add("select-end");
        } else {
          bookBtn.disabled = true;
        }
      }

      // 6) Selection logic
      async function onDayClick(dateStr) {
        if (!currentName) {
          await infoModal("먼저 이름을 입력하고 입장 버튼을 눌러주세요.");
          return;
        }

        const who = bookingsByDay.get(dateStr);
        // 이미 내 예약 → 취소 확인
        if (who && who === currentName) {
          const ok = await confirmModal(`${dateStr} 예약을 취소하시겠습니까?`);
          if (ok) cancelDates([dateStr]);
          return;
        }

        // 타인 예약 → 알림 (오버라이드 금지)
        if (who && who !== currentName) {
          await infoModal(`${dateStr}는 이미 ${who}님의 예약입니다.`);
          return;
        }

        // Empty day → selection for range booking
        if (!selectingStart || (selectingStart && selectingEnd)) {
          selectingStart = dateStr;
          selectingEnd = null;
        } else {
          // set end
          const [a, b] = [parseDate(selectingStart), parseDate(dateStr)].sort((x,y)=>x-y);
          selectingStart = fmtDate(a);
          selectingEnd = fmtDate(b);
          const nights = nightCount(selectingStart, selectingEnd);
          if (nights < minNights) {
            await infoModal(`최소 ${minNights}일 이상 연속으로 선택해야 합니다.`);
            // keep end but disable booking until enough days
          }
          // 예약 확정 확인 및 충돌 검사
          if (nights >= minNights) {
            const dates = rangeInclusive(a, b);
            const conflicts = dates.filter(d => {
              const w = bookingsByDay.get(d);
              return w && w !== currentName;
            });
            if (conflicts.length > 0) {
              await infoModal(`선택한 기간에 이미 예약된 날짜가 포함되어 있습니다.`);
              selectingStart = null;
              selectingEnd = null;
              paintSelection();
              return;
            }
            // 예약자 선택 (현재 이름이 없거나 변경 원할 때)
            let booker = currentName;
            if (!booker) {
              const picked = await selectMemberModal();
              if (!picked) return; // 취소
              setName(picked);
              booker = picked;
            }
            const msg = `${selectingStart} ~ ${selectingEnd} (${nights}일) 예약을 확정하시겠습니까?`;
            const ok = await confirmModal(msg);
            if (ok) {
              await bookDates(dates, booker);
              selectingStart = null;
              selectingEnd = null;
              paintSelection();
            }
          }
        }
        paintSelection();
      }

      // 7) Booking/cancel operations
      async function bookDates(dateList, memberName) {
        if (isDemoMode) {
          for (const day of dateList) bookingsByDay.set(day, memberName);
          paintBookings();
          try {
            localStorage.setItem("bookings_local", JSON.stringify([...bookingsByDay.entries()]));
          } catch {}
          return;
        }
        // Upsert rows; last write wins (intentionally permissive)
        const rows = dateList.map(day => ({ day, member_name: memberName }));
        const { error } = await client.from("bookings").upsert(rows, { onConflict: "day" });
        if (error) {
          console.error(error);
          await infoModal("예약 중 오류가 발생했습니다.");
        }
      }

      async function cancelDates(dateList) {
        if (isDemoMode) {
          for (const day of dateList) bookingsByDay.delete(day);
          paintBookings();
          try {
            localStorage.setItem("bookings_local", JSON.stringify([...bookingsByDay.entries()]));
          } catch {}
          return;
        }
        const { error } = await client.from("bookings").delete().in("day", dateList);
        if (error) {
          console.error(error);
          await infoModal("취소 중 오류가 발생했습니다.");
        }
      }

      // 8) Summary
      function renderSummary() {
        const counts = new Map();
        for (const [day, who] of bookingsByDay.entries()) {
          counts.set(who, (counts.get(who) || 0) + 1);
        }
        const entries = [...counts.entries()].sort((a,b) => a[0].localeCompare(b[0]));
        summaryBody.innerHTML = entries.map(([name, total]) => `<tr><td>${name}</td><td>${total}</td></tr>`).join("") || `<tr><td colspan="2" class="muted">예약이 없습니다.</td></tr>`;
      }

      // 9) Range booking button
      bookBtn.addEventListener("click", async () => {
        if (!selectingStart || !selectingEnd) return;
        const nights = nightCount(selectingStart, selectingEnd);
        if (nights < minNights) {
          await infoModal(`최소 ${minNights}일 이상 연속으로 선택해야 합니다.`);
          return;
        }
        const [a, b] = [parseDate(selectingStart), parseDate(selectingEnd)].sort((x,y)=>x-y);
        const dates = rangeInclusive(a, b);
        // 충돌 금지: 타인 예약 포함 시 거절
        const others = dates.filter(d => {
          const who = bookingsByDay.get(d);
          return who && who !== currentName;
        });
        if (others.length > 0) {
          await infoModal(`선택한 기간에 이미 예약된 날짜가 포함되어 있습니다.`);
          return;
        }
        // 예약자 선택 (현재 이름이 없으면 선택)
        let booker = currentName;
        if (!booker) {
          const picked = await selectMemberModal();
          if (!picked) return;
          setName(picked);
          booker = picked;
        }
        const ok = await confirmModal(`${selectingStart} ~ ${selectingEnd} (${nights}일) 예약을 확정하시겠습니까?`);
        if (!ok) return;

        await bookDates(dates, booker);
        // Reset selection
        selectingStart = null;
        selectingEnd = null;
        paintSelection();
      });

      // 10) Name handling
      function setName(name) {
        currentName = name.trim();
        if (!isAllowedMember(currentName)) {
          infoModal("허용된 멤버 이름이 아닙니다. 목록에서 선택해주세요.");
          return;
        }
        localStorage.setItem("member_name", currentName);
        nameInput.value = currentName;
        updateNameStatus();
        paintBookings();
      }

      saveNameBtn.addEventListener("click", async () => {
        const val = nameInput.value.trim();
        if (!val) { await infoModal("이름을 입력해주세요."); return; }
        if (!isAllowedMember(val)) { await infoModal("허용된 멤버 이름이 아닙니다. 목록에서 선택해주세요."); return; }
        setName(val);
      });

      // 11) Load initial data and subscribe to realtime
      async function loadInitial() {
        if (isDemoMode) {
          try {
            const raw = localStorage.getItem("bookings_local");
            const arr = raw ? JSON.parse(raw) : [];
            bookingsByDay = new Map(arr);
          } catch { bookingsByDay = new Map(); }
          paintBookings();
          return;
        }
        const start = fmtDate(new Date(calendarStartYear, calendarStartMonthIdx, 1));
        const end = fmtDate(new Date(calendarStartYear, calendarStartMonthIdx + monthsToShow, 0));
        const { data, error } = await client
          .from("bookings")
          .select("day, member_name")
          .gte("day", start)
          .lte("day", end);
        if (error) {
          console.error(error);
          return;
        }
        bookingsByDay.clear();
        for (const row of data) bookingsByDay.set(row.day, row.member_name);
        paintBookings();
      }

      function subscribeRealtime() {
        if (isDemoMode) return; // no realtime in demo/local mode
        client
          .channel("bookings-ch")
          .on(
            "postgres_changes",
            { event: "*", schema: "public", table: "bookings" },
            (payload) => {
              if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
                bookingsByDay.set(payload.new.day, payload.new.member_name);
              } else if (payload.eventType === "DELETE") {
                bookingsByDay.delete(payload.old.day);
              }
              paintBookings();
            }
          )
          .subscribe();
      }

      // 12) Init
      (function init() {
        if (currentName) {
          if (!isAllowedMember(currentName)) {
            currentName = "";
            localStorage.removeItem("member_name");
          }
          nameInput.value = currentName;
          updateNameStatus();
        }
        renderMonths();
        loadInitial();
        subscribeRealtime();
      })();
    </script>
  </body>
</html>
